pub type WdlWord = [u8; 5];

pub static DEFAULT_START_WORD: WdlWord = *b"tares";

// Import the static word lists generated by build.rs
include!(concat!(env!("OUT_DIR"), "/words-generated.rs"));

pub fn all(alt_words: bool) -> Vec<WdlWord> {
    if alt_words {
        ALT_WORDS.to_vec()
    } else {
        ALL_WORDS.to_vec()
    }
}

pub fn answers() -> Vec<WdlWord> {
    ALL_WORDS[0..ANSWER_WORDS_END].to_vec()
}

#[derive(PartialEq, Debug, Copy, Clone)]
pub enum Tagged {
    Answer(WdlWord),
    Probe(WdlWord),
}

impl Tagged {
    pub fn unwrap(self) -> WdlWord {
        match self {
            Self::Answer(w) => w,
            Self::Probe(w) => w,
        }
    }

    pub fn is_answer(self) -> bool {
        match self {
            Self::Answer(_) => true,
            _ => false,
        }
    }
}

pub fn tagged() -> Vec<Tagged> {
    let answers = ALL_WORDS[0..ANSWER_WORDS_END]
        .iter()
        .map(|&w| Tagged::Answer(w));
    let probes = ALL_WORDS[ANSWER_WORDS_END..ALL_WORDS.len()]
        .iter()
        .map(|&w| Tagged::Probe(w));
    let t: Vec<Tagged> = answers.chain(probes).collect();
    t
}

/// Validates that the provided word is in the list of all allowed
/// words, and returns a static reference to the word in the list.
/// This simplifies lifetime management for client code.
pub fn to_static_word(word: &str, answers_only: bool, alt_words: bool) -> Result<WdlWord, String> {
    if word.len() != 5 {
        return Err("Word must have 5 letters".into());
    }
    let list = if answers_only {
        answers()
    } else {
        all(alt_words)
    };
    // Copy the letters in word into a byte buffer as we can't convery
    // a str to an array of bytes directly
    let mut temp: [u8; 5] = [0; 5];
    word.bytes().zip(temp.iter_mut()).for_each(|(b, p)| *p = b);
    // Return the matching word in the static
    // probe word list, or an error if it's not in the list.
    if let Some(entry) = list.iter().find(|w| **w == temp) {
        Ok(*entry)
    } else {
        Err(format!(
            "The word '{word}' is not in the list of valid words"
        ))
    }
}

#[cfg(test)]
mod tests {
    use super::*;

    #[test]
    fn check_tagged() {
        let list = tagged();
        assert_eq!(list.len(), all(false).len());
        assert_eq!(list[0], Tagged::Answer(all(false)[0]));
        assert_eq!(
            *(list.last().unwrap()),
            Tagged::Probe(*(all(false).last().unwrap()))
        );
        let start_of_probe = list
            .iter()
            .find(|item| match item {
                Tagged::Probe(_) => true,
                _ => false,
            })
            .unwrap();
        assert_eq!(Tagged::Probe(all(false)[ANSWER_WORDS_END]), *start_of_probe);
    }
    #[test]
    fn to_static_word_finds_known_word() {
        assert_eq!(to_static_word("grass", false, false), Ok(*b"grass"));
    }

    #[test]
    #[should_panic]
    fn to_static_word_checks_length() {
        to_static_word("wibble", false, false).unwrap();
    }

    #[test]
    #[should_panic]
    fn to_static_word_invalid_word() {
        to_static_word("xxxxx", false, false).unwrap();
    }

    #[test]
    #[should_panic]
    fn to_static_word_detects_probe_word_used_as_answer_word() {
        to_static_word("caber", true, false).unwrap();
    }
}
